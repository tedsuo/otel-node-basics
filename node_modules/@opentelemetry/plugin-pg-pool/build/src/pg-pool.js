"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.PostgresPoolPlugin = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const enums_1 = require("./enums");
const shimmer = require("shimmer");
const utils = require("./utils");
const version_1 = require("./version");
class PostgresPoolPlugin extends core_1.BasePlugin {
    constructor(moduleName) {
        super('@opentelemetry/plugin-pg-pool', version_1.VERSION);
        this.moduleName = moduleName;
        this.supportedVersions = ['2.*', '3.*'];
        this._config = {};
    }
    patch() {
        shimmer.wrap(this._moduleExports.prototype, 'connect', this._getPoolConnectPatch());
        return this._moduleExports;
    }
    unpatch() {
        shimmer.unwrap(this._moduleExports.prototype, 'connect');
    }
    _getPoolConnectPatch() {
        const plugin = this;
        return (originalConnect) => {
            plugin._logger.debug(`Patching ${PostgresPoolPlugin.COMPONENT}.prototype.connect`);
            return function connect(callback) {
                const jdbcString = utils.getJDBCString(this.options);
                // setup span
                const span = plugin._tracer.startSpan(`${PostgresPoolPlugin.COMPONENT}.connect`, {
                    kind: api_1.SpanKind.CLIENT,
                    attributes: {
                        [enums_1.AttributeNames.COMPONENT]: PostgresPoolPlugin.COMPONENT,
                        [enums_1.AttributeNames.DB_TYPE]: PostgresPoolPlugin.DB_TYPE,
                        [enums_1.AttributeNames.DB_INSTANCE]: this.options.database,
                        [enums_1.AttributeNames.PEER_HOSTNAME]: this.options.host,
                        [enums_1.AttributeNames.PEER_ADDRESS]: jdbcString,
                        [enums_1.AttributeNames.PEER_PORT]: this.options.port,
                        [enums_1.AttributeNames.DB_USER]: this.options.user,
                        [enums_1.AttributeNames.IDLE_TIMEOUT_MILLIS]: this.options
                            .idleTimeoutMillis,
                        [enums_1.AttributeNames.MAX_CLIENT]: this.options.maxClient,
                    },
                });
                if (callback) {
                    const parentSpan = plugin._tracer.getCurrentSpan();
                    callback = utils.patchCallback(span, callback);
                    // If a parent span exists, bind the callback
                    if (parentSpan) {
                        callback = plugin._tracer.bind(callback);
                    }
                }
                const connectResult = originalConnect.call(this, callback);
                // No callback was provided, return a promise instead
                if (connectResult instanceof Promise) {
                    const connectResultPromise = connectResult;
                    return plugin._tracer.bind(connectResultPromise
                        .then((result) => {
                        // Return a pass-along promise which ends the span and then goes to user's orig resolvers
                        return new Promise((resolve, _) => {
                            span.setStatus({ code: api_1.CanonicalCode.OK });
                            span.end();
                            resolve(result);
                        });
                    })
                        .catch((error) => {
                        return new Promise((_, reject) => {
                            span.setStatus({
                                code: api_1.CanonicalCode.UNKNOWN,
                                message: error.message,
                            });
                            span.end();
                            reject(error);
                        });
                    }));
                }
                // Else a callback was provided, so just return the result
                return connectResult;
            };
        };
    }
}
exports.PostgresPoolPlugin = PostgresPoolPlugin;
PostgresPoolPlugin.COMPONENT = 'pg-pool';
PostgresPoolPlugin.DB_TYPE = 'sql';
exports.plugin = new PostgresPoolPlugin(PostgresPoolPlugin.COMPONENT);
//# sourceMappingURL=pg-pool.js.map