"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceSendCommand = exports.traceConnection = void 0;
const api_1 = require("@opentelemetry/api");
const ioredis_1 = require("./ioredis");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const endSpan = (span, err) => {
    if (err) {
        span.setStatus({
            code: api_1.CanonicalCode.UNKNOWN,
            message: err.message,
        });
    }
    else {
        span.setStatus({ code: api_1.CanonicalCode.OK });
    }
    span.end();
};
exports.traceConnection = (tracer, original) => {
    return function () {
        const span = tracer.startSpan('connect', {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
                [semantic_conventions_1.DatabaseAttribute.DB_SYSTEM]: ioredis_1.IORedisPlugin.DB_SYSTEM,
                [semantic_conventions_1.DatabaseAttribute.DB_STATEMENT]: 'connect',
            },
        });
        const { host, port } = this.options;
        span.setAttributes({
            [semantic_conventions_1.GeneralAttribute.NET_PEER_HOSTNAME]: host,
            [semantic_conventions_1.GeneralAttribute.NET_PEER_PORT]: port,
            [semantic_conventions_1.GeneralAttribute.NET_PEER_ADDRESS]: `redis://${host}:${port}`,
        });
        try {
            const client = original.apply(this, arguments);
            endSpan(span, null);
            return client;
        }
        catch (error) {
            endSpan(span, error);
            throw error;
        }
    };
};
const defaultDbStatementSerializer = (cmdName, cmdArgs) => Array.isArray(cmdArgs) && cmdArgs.length
    ? `${cmdName} ${cmdArgs.join(' ')}`
    : cmdName;
exports.traceSendCommand = (tracer, original, config) => {
    const dbStatementSerializer = (config === null || config === void 0 ? void 0 : config.dbStatementSerializer) || defaultDbStatementSerializer;
    return function (cmd) {
        if (arguments.length < 1 || typeof cmd !== 'object') {
            return original.apply(this, arguments);
        }
        // Do not trace if there is not parent span
        if (tracer.getCurrentSpan() === undefined) {
            return original.apply(this, arguments);
        }
        const span = tracer.startSpan(cmd.name, {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
                [semantic_conventions_1.DatabaseAttribute.DB_SYSTEM]: ioredis_1.IORedisPlugin.DB_SYSTEM,
                [semantic_conventions_1.DatabaseAttribute.DB_STATEMENT]: dbStatementSerializer(cmd.name, cmd.args),
            },
        });
        const { host, port } = this.options;
        span.setAttributes({
            [semantic_conventions_1.GeneralAttribute.NET_PEER_HOSTNAME]: host,
            [semantic_conventions_1.GeneralAttribute.NET_PEER_PORT]: port,
            [semantic_conventions_1.GeneralAttribute.NET_PEER_ADDRESS]: `redis://${host}:${port}`,
        });
        try {
            const result = original.apply(this, arguments);
            endSpan(span, null);
            return result;
        }
        catch (error) {
            endSpan(span, error);
            throw error;
        }
    };
};
//# sourceMappingURL=utils.js.map