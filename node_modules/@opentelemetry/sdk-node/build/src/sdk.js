"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSDK = void 0;
const api_1 = require("@opentelemetry/api");
const metrics_1 = require("@opentelemetry/metrics");
const node_1 = require("@opentelemetry/node");
const resources_1 = require("@opentelemetry/resources");
const tracing_1 = require("@opentelemetry/tracing");
const resource_detector_aws_1 = require("@opentelemetry/resource-detector-aws");
const resource_detector_gcp_1 = require("@opentelemetry/resource-detector-gcp");
/** This class represents everything needed to register a fully configured OpenTelemetry Node.js SDK */
class NodeSDK {
    /**
     * Create a new NodeJS SDK instance
     */
    constructor(configuration = {}) {
        var _a, _b, _c;
        this._resource = (_a = configuration.resource) !== null && _a !== void 0 ? _a : new resources_1.Resource({});
        this._autoDetectResources = (_b = configuration.autoDetectResources) !== null && _b !== void 0 ? _b : true;
        if (configuration.spanProcessor || configuration.traceExporter) {
            const tracerProviderConfig = {};
            if (typeof configuration.logLevel === 'number') {
                tracerProviderConfig.logLevel = configuration.logLevel;
            }
            if (configuration.logger) {
                tracerProviderConfig.logger = configuration.logger;
            }
            if (configuration.plugins) {
                tracerProviderConfig.plugins = configuration.plugins;
            }
            if (configuration.sampler) {
                tracerProviderConfig.sampler = configuration.sampler;
            }
            if (configuration.traceParams) {
                tracerProviderConfig.traceParams = configuration.traceParams;
            }
            const spanProcessor = (_c = configuration.spanProcessor) !== null && _c !== void 0 ? _c : new tracing_1.BatchSpanProcessor(configuration.traceExporter);
            this.configureTracerProvider(tracerProviderConfig, spanProcessor, configuration.contextManager, configuration.textMapPropagator);
        }
        if (configuration.metricExporter) {
            const meterConfig = {};
            if (configuration.metricBatcher) {
                meterConfig.batcher = configuration.metricBatcher;
            }
            if (configuration.metricExporter) {
                meterConfig.exporter = configuration.metricExporter;
            }
            if (typeof configuration.metricInterval === 'number') {
                meterConfig.interval = configuration.metricInterval;
            }
            if (typeof configuration.logLevel === 'number') {
                meterConfig.logLevel = configuration.logLevel;
            }
            if (configuration.logger) {
                meterConfig.logger = configuration.logger;
            }
            this.configureMeterProvider(meterConfig);
        }
    }
    /** Set configurations required to register a NodeTracerProvider */
    configureTracerProvider(tracerConfig, spanProcessor, contextManager, textMapPropagator) {
        this._tracerProviderConfig = {
            tracerConfig,
            spanProcessor,
            contextManager,
            textMapPropagator,
        };
    }
    /** Set configurations needed to register a MeterProvider */
    configureMeterProvider(config) {
        this._meterProviderConfig = config;
    }
    /** Detect resource attributes */
    async detectResources(config) {
        const internalConfig = Object.assign({ detectors: [resource_detector_aws_1.awsEc2Detector, resource_detector_gcp_1.gcpDetector, resources_1.envDetector] }, config);
        this.addResource(await resources_1.detectResources(internalConfig));
    }
    /** Manually add a resource */
    addResource(resource) {
        this._resource = this._resource.merge(resource);
    }
    /**
     * Once the SDK has been configured, call this method to construct SDK components and register them with the OpenTelemetry API.
     */
    async start() {
        if (this._autoDetectResources) {
            await this.detectResources();
        }
        if (this._tracerProviderConfig) {
            const tracerProvider = new node_1.NodeTracerProvider(Object.assign(Object.assign({}, this._tracerProviderConfig.tracerConfig), { resource: this._resource }));
            tracerProvider.addSpanProcessor(this._tracerProviderConfig.spanProcessor);
            tracerProvider.register({
                contextManager: this._tracerProviderConfig.contextManager,
                propagator: this._tracerProviderConfig.textMapPropagator,
            });
        }
        if (this._meterProviderConfig) {
            const meterProvider = new metrics_1.MeterProvider(Object.assign(Object.assign({}, this._meterProviderConfig), { resource: this._resource }));
            api_1.metrics.setGlobalMeterProvider(meterProvider);
        }
    }
}
exports.NodeSDK = NodeSDK;
//# sourceMappingURL=sdk.js.map