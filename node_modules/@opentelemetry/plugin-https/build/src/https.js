"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.HttpsPlugin = void 0;
const plugin_http_1 = require("@opentelemetry/plugin-http");
const https = require("https");
const url_1 = require("url");
const semver = require("semver");
const shimmer = require("shimmer");
const utils = require("./utils");
/**
 * Https instrumentation plugin for Opentelemetry
 */
class HttpsPlugin extends plugin_http_1.HttpPlugin {
    /** Constructs a new HttpsPlugin instance. */
    constructor(version) {
        super('https', version);
        this.version = version;
    }
    /**
     * Patches HTTPS incoming and outcoming request functions.
     */
    patch() {
        this._logger.debug('applying patch to %s@%s', this.moduleName, this.version);
        if (this._moduleExports &&
            this._moduleExports.Server &&
            this._moduleExports.Server.prototype) {
            shimmer.wrap(this._moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());
        }
        else {
            this._logger.error('Could not apply patch to %s.emit. Interface is not as expected.', this.moduleName);
        }
        shimmer.wrap(this._moduleExports, 'request', this._getPatchHttpsOutgoingRequestFunction());
        // In Node 8-12, http.get calls a private request method, therefore we patch it
        // here too.
        if (semver.satisfies(this.version, '>=8.0.0')) {
            shimmer.wrap(this._moduleExports, 'get', this._getPatchHttpsOutgoingGetFunction(https.request));
        }
        return this._moduleExports;
    }
    /** Patches HTTPS outgoing requests */
    _getPatchHttpsOutgoingRequestFunction() {
        return (original) => {
            const plugin = this;
            return function httpsOutgoingRequest(options, ...args) {
                // Makes sure options will have default HTTPS parameters
                if (typeof options === 'object' && !(options instanceof url_1.URL)) {
                    options = Object.assign({}, options);
                    utils.setDefaultOptions(options);
                }
                return plugin._getPatchOutgoingRequestFunction()(original)(options, ...args);
            };
        };
    }
    /** Patches HTTPS outgoing get requests */
    _getPatchHttpsOutgoingGetFunction(clientRequest) {
        return (original) => {
            return function httpsOutgoingRequest(options, ...args) {
                return exports.plugin._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);
            };
        };
    }
    /** Unpatches all HTTPS patched function. */
    unpatch() {
        if (this._moduleExports &&
            this._moduleExports.Server &&
            this._moduleExports.Server.prototype) {
            shimmer.unwrap(this._moduleExports.Server.prototype, 'emit');
        }
        shimmer.unwrap(this._moduleExports, 'request');
        if (semver.satisfies(this.version, '>=8.0.0')) {
            shimmer.unwrap(this._moduleExports, 'get');
        }
    }
}
exports.HttpsPlugin = HttpsPlugin;
exports.plugin = new HttpsPlugin(process.versions.node);
//# sourceMappingURL=https.js.map