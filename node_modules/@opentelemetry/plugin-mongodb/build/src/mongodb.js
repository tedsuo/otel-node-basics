"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.MongoDBPlugin = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const shimmer = require("shimmer");
const types_1 = require("./types");
const version_1 = require("./version");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
/** MongoDBCore instrumentation plugin for OpenTelemetry */
class MongoDBPlugin extends core_1.BasePlugin {
    constructor(moduleName) {
        super('@opentelemetry/plugin-mongodb-core', version_1.VERSION);
        this.moduleName = moduleName;
        this._SERVER_METHODS = ['insert', 'update', 'remove', 'command'];
        this._CURSOR_METHODS = ['_next', 'next'];
        this._hasPatched = false;
        this.supportedVersions = ['>=2 <4'];
    }
    /**
     * Patches MongoDB operations.
     */
    patch() {
        this._logger.debug('Patching MongoDB');
        if (this._hasPatched === true) {
            this._logger.debug('Patch is already applied, ignoring.');
            return this._moduleExports;
        }
        if (this._moduleExports.Server) {
            for (const fn of this._SERVER_METHODS) {
                this._logger.debug(`patching mongodb.Server.prototype.${fn}`);
                shimmer.wrap(this._moduleExports.Server.prototype, 
                // Forced to ignore due to incomplete typings
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore
                fn, this._getPatchCommand(fn));
            }
        }
        if (this._moduleExports.Cursor) {
            this._logger.debug('patching mongodb.Cursor.prototype functions:', this._CURSOR_METHODS);
            shimmer.massWrap([this._moduleExports.Cursor.prototype], this._CURSOR_METHODS, 
            // tslint:disable-next-line:no-any
            this._getPatchCursor());
        }
        this._hasPatched = true;
        return this._moduleExports;
    }
    /** Unpatches all MongoDB patched functions. */
    unpatch() {
        shimmer.massUnwrap([this._moduleExports.Server.prototype], this._SERVER_METHODS);
        shimmer.massUnwrap([this._moduleExports.Cursor.prototype], this._CURSOR_METHODS);
    }
    /** Creates spans for Command operations */
    _getPatchCommand(operationName) {
        const plugin = this;
        return (original) => {
            return function patchedServerCommand(ns, commands, options, callback) {
                const currentSpan = plugin._tracer.getCurrentSpan();
                const resultHandler = typeof options === 'function' ? options : callback;
                if (!currentSpan ||
                    typeof resultHandler !== 'function' ||
                    typeof commands !== 'object') {
                    return original.apply(this, arguments);
                }
                const command = commands instanceof Array ? commands[0] : commands;
                const commandType = plugin._getCommandType(command);
                const type = commandType === types_1.MongodbCommandType.UNKNOWN
                    ? operationName
                    : commandType;
                const span = plugin._tracer.startSpan(`mongodb.${type}`, {
                    kind: api_1.SpanKind.CLIENT,
                });
                plugin._populateAttributes(span, ns, command, this);
                return original.call(this, ns, commands, plugin._patchEnd(span, resultHandler));
            };
        };
    }
    /**
     * Get the mongodb command type from the object.
     * @param command Internal mongodb command object
     */
    _getCommandType(command) {
        if (command.createIndexes !== undefined) {
            return types_1.MongodbCommandType.CREATE_INDEXES;
        }
        else if (command.findandmodify !== undefined) {
            return types_1.MongodbCommandType.FIND_AND_MODIFY;
        }
        else if (command.ismaster !== undefined) {
            return types_1.MongodbCommandType.IS_MASTER;
        }
        else if (command.count !== undefined) {
            return types_1.MongodbCommandType.COUNT;
        }
        else {
            return types_1.MongodbCommandType.UNKNOWN;
        }
    }
    /**
     * Populate span's attributes by fetching related metadata from the context
     * @param span span to add attributes to
     * @param ns mongodb namespace
     * @param command mongodb internal representation of a command
     * @param topology mongodb internal representation of the network topology
     */
    _populateAttributes(span, ns, command, topology) {
        var _a, _b, _c, _d, _e, _f, _g;
        // add network attributes to determine the remote server
        if (topology && topology.s) {
            span.setAttributes({
                [semantic_conventions_1.GeneralAttribute.NET_HOST_NAME]: `${(_b = (_a = topology.s.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : topology.s.host}`,
                [semantic_conventions_1.GeneralAttribute.NET_HOST_PORT]: `${(_d = (_c = topology.s.options) === null || _c === void 0 ? void 0 : _c.port) !== null && _d !== void 0 ? _d : topology.s.port}`,
            });
        }
        // The namespace is a combination of the database name and the name of the
        // collection or index, like so: [database-name].[collection-or-index-name].
        // It could be a string or an instance of MongoDBNamespace, as such we
        // always coerce to a string to extract db and collection.
        const [dbName, dbCollection] = ns.toString().split('.');
        // add database related attributes
        span.setAttributes({
            [semantic_conventions_1.DatabaseAttribute.DB_SYSTEM]: 'mongodb',
            [semantic_conventions_1.DatabaseAttribute.DB_NAME]: dbName,
            [semantic_conventions_1.DatabaseAttribute.DB_MONGODB_COLLECTION]: dbCollection,
        });
        if (command === undefined)
            return;
        // capture parameters within the query as well if enhancedDatabaseReporting is enabled.
        const commandObj = (_f = (_e = command.query) !== null && _e !== void 0 ? _e : command.q) !== null && _f !== void 0 ? _f : command;
        const query = ((_g = this._config) === null || _g === void 0 ? void 0 : _g.enhancedDatabaseReporting) === true
            ? commandObj
            : Object.keys(commandObj).reduce((obj, key) => {
                obj[key] = '?';
                return obj;
            }, {});
        span.setAttribute('db.statement', JSON.stringify(query));
    }
    /** Creates spans for Cursor operations */
    _getPatchCursor() {
        const plugin = this;
        return (original) => {
            return function patchedCursorCommand(...args) {
                const currentSpan = plugin._tracer.getCurrentSpan();
                const resultHandler = args[0];
                if (!currentSpan || typeof resultHandler !== 'function') {
                    return original.apply(this, args);
                }
                const span = plugin._tracer.startSpan('mongodb.query', {
                    kind: api_1.SpanKind.CLIENT,
                });
                plugin._populateAttributes(span, this.ns, this.cmd, this.topology);
                return original.call(this, plugin._patchEnd(span, resultHandler));
            };
        };
    }
    /**
     * Ends a created span.
     * @param span The created span to end.
     * @param resultHandler A callback function.
     */
    _patchEnd(span, resultHandler) {
        return function patchedEnd(...args) {
            const error = args[0];
            if (error instanceof Error) {
                span.setStatus({
                    code: api_1.CanonicalCode.UNKNOWN,
                    message: error.message,
                });
            }
            else {
                span.setStatus({
                    code: api_1.CanonicalCode.OK,
                });
            }
            span.end();
            return resultHandler.apply(this, args);
        };
    }
}
exports.MongoDBPlugin = MongoDBPlugin;
exports.plugin = new MongoDBPlugin('mongodb');
//# sourceMappingURL=mongodb.js.map