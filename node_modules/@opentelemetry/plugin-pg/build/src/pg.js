"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.PostgresPlugin = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const shimmer = require("shimmer");
const utils = require("./utils");
const version_1 = require("./version");
class PostgresPlugin extends core_1.BasePlugin {
    constructor(moduleName) {
        super('@opentelemetry/plugin-pg', version_1.VERSION);
        this.moduleName = moduleName;
        this.supportedVersions = ['7.*', '8.*'];
        this._config = {};
    }
    patch() {
        if (!core_1.isWrapped(this._moduleExports.Client.prototype.query)) {
            shimmer.wrap(this._moduleExports.Client.prototype, 'query', this._getClientQueryPatch());
        }
        return this._moduleExports;
    }
    unpatch() {
        shimmer.unwrap(this._moduleExports.Client.prototype, 'query');
    }
    _getClientQueryPatch() {
        const plugin = this;
        return (original) => {
            plugin._logger.debug(`Patching ${PostgresPlugin.COMPONENT}.Client.prototype.query`);
            return function query(...args) {
                let span;
                // Handle different client.query(...) signatures
                if (typeof args[0] === 'string') {
                    const query = args[0];
                    if (args.length > 1 && args[1] instanceof Array) {
                        const params = args[1];
                        span = utils.handleParameterizedQuery.call(this, plugin._tracer, plugin._config, query, params);
                    }
                    else {
                        span = utils.handleTextQuery.call(this, plugin._tracer, query);
                    }
                }
                else if (typeof args[0] === 'object') {
                    const queryConfig = args[0];
                    span = utils.handleConfigQuery.call(this, plugin._tracer, plugin._config, queryConfig);
                }
                else {
                    return utils.handleInvalidQuery.call(this, plugin._tracer, original, ...args);
                }
                // Bind callback to parent span
                if (args.length > 0) {
                    const parentSpan = plugin._tracer.getCurrentSpan();
                    if (typeof args[args.length - 1] === 'function') {
                        // Patch ParameterQuery callback
                        args[args.length - 1] = utils.patchCallback(span, args[args.length - 1]);
                        // If a parent span exists, bind the callback
                        if (parentSpan) {
                            args[args.length - 1] = plugin._tracer.bind(args[args.length - 1]);
                        }
                    }
                    else if (typeof args[0].callback === 'function') {
                        // Patch ConfigQuery callback
                        let callback = utils.patchCallback(span, args[0].callback);
                        // If a parent span existed, bind the callback
                        if (parentSpan) {
                            callback = plugin._tracer.bind(callback);
                        }
                        // Copy the callback instead of writing to args.callback so that we don't modify user's
                        // original callback reference
                        args[0] = Object.assign(Object.assign({}, args[0]), { callback });
                    }
                }
                // Perform the original query
                const result = original.apply(this, args);
                // Bind promise to parent span and end the span
                if (result instanceof Promise) {
                    return result
                        .then((result) => {
                        // Return a pass-along promise which ends the span and then goes to user's orig resolvers
                        return new Promise(resolve => {
                            span.setStatus({ code: api_1.CanonicalCode.OK });
                            span.end();
                            resolve(result);
                        });
                    })
                        .catch((error) => {
                        return new Promise((_, reject) => {
                            span.setStatus({
                                code: api_1.CanonicalCode.UNKNOWN,
                                message: error.message,
                            });
                            span.end();
                            reject(error);
                        });
                    });
                }
                // else returns void
                return result; // void
            };
        };
    }
}
exports.PostgresPlugin = PostgresPlugin;
PostgresPlugin.COMPONENT = 'pg';
PostgresPlugin.DB_TYPE = 'sql';
PostgresPlugin.BASE_SPAN_NAME = PostgresPlugin.COMPONENT + '.query';
exports.plugin = new PostgresPlugin(PostgresPlugin.COMPONENT);
//# sourceMappingURL=pg.js.map